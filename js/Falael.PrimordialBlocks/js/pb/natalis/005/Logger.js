//	R0Q2?/daniel/20210727
//	- TODO: add configuration for time stamping `[datetime.toISOString()]` and log level prefixing `FATAL ERROR: `, `ERROR: `, `WARNING: `, `INFO: `, `DEBUG: `, `TRACE: `
//	- TODO: validate input parameters where meaningful in functions
//	- TODO: allow specifying a function as a loggerTarget ??
//	- DOC: finish documentation
//	- OPT: rewrite the print* familty the same way the log-methods are implemented
"use strict";

const { Type, CallableType } = require("-/pb/natalis/000/Native.js");
const { Runtime } = require("-/pb/natalis/000/Runtime.js")
const { ArgumentException, NotSupportedException, NotImplementedException } = require("-/pb/natalis/003/Exception.js");

const cap_Process_stdout = Runtime.supports("Process:stdout");
const cap_Process_stderr = Runtime.supports("Process:stderr");

module.exports =

//	Class: 
class Logger
{
	//	Field: Info category - bulk data dumps, targeted at developers.
	static Dump = Symbol("Dump");
	//	Field: Info category - code execution trace points (e.g. `Context.logger.trace("ClassName.methodName", 100)`); targeted at developers and system administrators.
	static Trace = Symbol("Trace");
	//	Field: Info category - information on application execution steps meaningful to the applications user.
	static Info = Symbol("Info");
	//	Field: Info category - information on application execution that potentially requires action or might explain unexpected future application behaviour.
	static Warning = Symbol("Warning");
	//	Field: Info category - recoverable application error.
	//	Remarks: This info category covers only errors generated by the application. Errors generated by the running environment that cannot be cought and rethrown are out of the scope
	//		of the logger. Examples for such errors are: a syntactic error making the code unparseable; any unhandled error causing the process to exits.
	static Error = Symbol("Error");
	//	Field: Info category - unrecoverable application error - this should be the last message printed out before the application exits with an error code.
	//	Remarks: This info category covers only errors generated by the application. Errors generated by the running environment that cannot be cought and rethrown are out of the scope
	//		of the logger. Examples for such errors are: a syntactic error making the code unparseable; any unhandled error causing the process to exits.
	static Fatal = Symbol("Fatal");

	static isLogLevel(value)
	{
		return value === Logger.Dump
			|| value === Logger.Trace
			|| value === Logger.Info
			|| value === Logger.Warning
			|| value === Logger.Error
			|| value === Logger.Fatal;
	}

	//	Field: Logger target - `console.log`.
	static ConsoleLog = Symbol("ConsoleLog");
	//	Field: Logger target - `console.warn`.
	static ConsoleWarn = Symbol("ConsoleWarn");
	//	Field: Logger target - `console.error`.
	static ConsoleError = Symbol("ConsoleError");
	
	static isLogTarget(value)
	{
		return value === Logger.ConsoleLog
			|| value === Logger.ConsoleWarn
			|| value === Logger.ConsoleError
			|| Type.isCallable(value);
	}

	//	Field: Logger target - `process.stdout.write`.
	static ProcessStdout = Symbol("ProcessStdout");
	//	Field: Logger target - `process.stderr.write`.
	static ProcessStderr = Symbol("ProcessStderr");

	static isPrintTarget(value)
	{
		return value === Logger.ProcessStdout
			|| value === Logger.ProcessStderr
	}

	constructor(routes = null, printRoutes = null, enableTime = true, decorate = null)
	{
		if (PB_DEBUG)
		{
			if (!Type.isNU(routes) && !Type.isArray(routes)) throw new ArgumentException(0x6D18E3, "routes", routes);
			if (!Type.isNU(routes) && routes.some(v => !Type.isArray(v) || v.length !== 2 || !Logger.isLogLevel(v[0]) || !Logger.isLogTarget(v[1]))) throw new ArgumentException(0xD4B070, "routes", routes);
			if (!Type.isNU(printRoutes) && !Type.isArray(printRoutes)) throw new ArgumentException(0xEB2E8C, "printRoutes", printRoutes);
			if (!Type.isNU(printRoutes) && printRoutes.some(v => !Type.isArray(v) || v.length !== 2 || !Logger.isLogLevel(v[0]) || !Logger.isPrintTarget(v[1]))) throw new ArgumentException(0x25B739, "printRoutes", printRoutes);
			if (!Type.isBoolean(enableTime)) throw new ArgumentException(0x65E249, "enableTime", enableTime);
			if (!Type.isNU(decorate) && !CallableType.isFunction(decorate)) throw new ArgumentException(0xF5DE65, "decorate", decorate);
		}

		if (Type.isNU(routes)) routes =
		[
			[Logger.Trace, Logger.ConsoleLog],
			[Logger.Dump, Logger.ConsoleLog],
			[Logger.Info, Logger.ConsoleLog],
			[Logger.Warning, Logger.ConsoleWarn],
			[Logger.Error, Logger.ConsoleError],
			[Logger.Fatal, Logger.ConsoleError],
		];
		if (Type.isNU(printRoutes)) printRoutes =
		[
			[Logger.Trace, Logger.ProcessStdout],
			[Logger.Dump, Logger.ProcessStdout],
			[Logger.Info, Logger.ProcessStdout],
			[Logger.Warning, Logger.ProcessStderr],
			[Logger.Error, Logger.ProcessStderr],
			[Logger.Fatal, Logger.ProcessStderr],
		];

		const routeGroups =
		{
			[Logger.Trace]: [],
			[Logger.Dump]: [],
			[Logger.Info]: [],
			[Logger.Warning]: [],
			[Logger.Error]: [],
			[Logger.Fatal]: [],
		};
		for (let length = routes.length, i = 0; i < length; ++i)
		{
			const [logLevel, loggingTarget] = routes[i];
			routeGroups[logLevel].push(loggingTarget);
		}
		const logLevelToMethodNameMap =
		[
			[Logger.Trace, "trace"],
			[Logger.Dump, "debug"],
			[Logger.Info, "info"],
			[Logger.Warning, "warn"],
			[Logger.Error, "error"],
			[Logger.Fatal, "fatal"],
		];
		for (let coll = Object.getOwnPropertySymbols(routeGroups), length = coll.length, i = 0; i < length; ++i)
		{
			const logLevel = coll[i];
			const loggingTargets = routeGroups[logLevel];
			let handler;
			switch (loggingTargets.length)
			{
				case 0: handler = () => { }; break;
				case 1: handler = _getHandler(logLevel, loggingTargets[0], decorate); break;
				default: handler = _getMultiHandler(logLevel, loggingTargets, decorate); break;
			}
			const methodName = logLevelToMethodNameMap.find(v => v[0] === logLevel)[1];
			this[methodName] = handler;
			this[logLevel] = handler;
		}
		this.time = enableTime ? console.time.bind(console) : () => { };
		this.timeEnd = enableTime ? console.timeEnd.bind(console) : () => { };

		function _getHandler(logLevel, target, decorate)
		{
			switch (target)
			{
				case Logger.ConsoleLog:
					if (decorate) return (...args) => console.log.apply(console, decorate(logLevel, args));
					return console.log.bind(console);
				case Logger.ConsoleWarn:
					if (decorate) return (...args) => console.warn.apply(console, decorate(logLevel, args));
					return console.warn.bind(console);
				case Logger.ConsoleError:
					if (decorate) return (...args) => console.error.apply(console, decorate(logLevel, args));
					return console.error.bind(console);
				default:
					if (decorate) return (...args) => target(decorate(logLevel, args));
					return target;
			}
		}

		function _getMultiHandler(logLevel, targets, decorate)
		{
			if (decorate) return (...args) =>
			{
				for (let length = targets.length, i = 0; i < length; ++i) switch (targets[i])
				{
					case Logger.ConsoleLog: console.log.apply(console, decorate(logLevel, args)); break;
					case Logger.ConsoleError: console.error.apply(console, decorate(logLevel, args)); break;
					case Logger.ConsoleWarn: console.warn.apply(console, decorate(logLevel, args)); break;
					default: target(decorate(logLevel, args)); break;
				}
			}
			else return (...args) =>
			{
				for (let length = targets.length, i = 0; i < length; ++i) switch (targets[i])
				{
					case Logger.ConsoleLog: console.log.apply(console, args); break;
					case Logger.ConsoleError: console.error.apply(console, args); break;
					case Logger.ConsoleWarn: console.warn.apply(console, logLevel); break;
					default: target(args); break;
				}
			}
		}

		const printRouteGroups =
		{
			[Logger.Trace]: [],
			[Logger.Dump]: [],
			[Logger.Info]: [],
			[Logger.Warning]: [],
			[Logger.Error]: [],
			[Logger.Fatal]: [],
		};
		for (let length = printRoutes.length, i = 0; i < length; ++i)
		{
			const [logLevel, loggingTarget] = printRoutes[i];
			printRouteGroups[logLevel].push(loggingTarget);
		}
		this._printRouteGroups = printRouteGroups;

		this._routes = routes;
		this._printRoutes = printRoutes;
		this._enableTime = enableTime;
		this._decorate = decorate;
	}

	static augment(logger, prefixDecorate = null, postfixDecorate = null)
	{
		if (PB_DEBUG)
		{
			if (!Type.isNU(prefixDecorate) && !CallableType.isFunction(prefixDecorate)) throw new ArgumentException(0xDE5F26, "prefixDecorate", prefixDecorate);
			if (!Type.isNU(postfixDecorate) && !CallableType.isFunction(postfixDecorate)) throw new ArgumentException(0xA53AE4, "postfixDecorate", postfixDecorate);
		}
		if (logger._decorate && prefixDecorate && postfixDecorate) return new Logger(logger._routes, logger._printRoutes, logger._enableTime, (logLevel, args) => postfixDecorate(logLevel, logger._decorate(logLevel, prefixDecorate(logLevel, args))));
		if (logger._decorate && prefixDecorate) return new Logger(logger._routes, logger._printRoutes, logger._enableTime, (logLevel, args) => logger._decorate(logLevel, prefixDecorate(logLevel, args)));
		if (logger._decorate && postfixDecorate) return new Logger(logger._routes, logger._printRoutes, logger._enableTime, (logLevel, args) => postfixDecorate(logLevel, logger._decorate(logLevel, args)));
		if (logger._decorate) return new Logger(logger._routes, logger._printRoutes, logger._enableTime, logger._decorate);
		if (prefixDecorate && postfixDecorate) return new Logger(logger._routes, logger._printRoutes, logger._enableTime, (logLevel, args) => postfixDecorate(logLevel, prefixDecorate(logLevel, args)));
		if (prefixDecorate) return new Logger(logger._routes, logger._printRoutes, logger._enableTime, prefixDecorate);
		if (postfixDecorate) return new Logger(logger._routes, logger._printRoutes, logger._enableTime, postfixDecorate);
		return new Logger(logger._routes, logger._printRoutes, logger._enableTime);
	}

	log(logLevel, ...args)
	{
		if (PB_DEBUG)
		{
			if (!Logger.isLogLevel(logLevel)) throw new ArgumentException(0xC2934A, "logLevel", logLevel);
		}
		this[logLevel](args);
	}

	trace(...args) { }

	debug(...args) { }

	info(...args) { }

	warn(...args) { }

	error(...args) { }

	fatal(...args) { }

	print(logLevel, ...args)
	{
		if (PB_DEBUG)
		{
			if (!cap_Process_stdout || !cap_Process_stderr) throw new NotSupportedException(0x39FD9C, "inline printout");
			if (!Logger.isLogLevel(logLevel)) throw new ArgumentException(0x521CAC, "logLevel", logLevel);
		}
		const targets = this._printRouteGroups[logLevel];
		if (targets.length === 0) return;
		for (let length = targets.length, i = 0; i < length; ++i)
		{
			let method, methodThis;
			switch (targets[i])
			{
				case Logger.ProcessStdout: method = process.stdout.write; methodThis = process.stdout; break;
				case Logger.ProcessStderr: method = process.stderr.write; methodThis = process.stderr; break;
				default: throw new NotImplementedException(0x405249);
			}
			for (let jlength = args.length, j = 0; j < jlength; ++j)
			{
				const jitem = args[j];
				let printout;
				try
				{
					printout = String(jitem);
				}
				catch (ex)
				{
					printout = "(unprintable)";
				}
				if (j !== 0) method.call(methodThis, " ");
				method.call(methodThis, printout);
			}
		}
	}

	printTrace(...args) { this.print(Logger.Trace, ...args) }

	printDebug(...args) { this.print(Logger.Debug, ...args) }

	printInfo(...args) { this.print(Logger.Info, ...args) }

	printWarn(...args) { this.print(Logger.Warn, ...args) }

	printError(...args) { this.print(Logger.Error, ...args) }

	printFatal(...args) { this.print(Logger.Fatal, ...args) }

	get routes() { return this._routes; }

	get printRoutes() { return this.printRoutes; }

	get enableTime() { return this._enableTime; }

	get decorate() { return this._decorate; }
}

module.exports.Logger = module.exports;