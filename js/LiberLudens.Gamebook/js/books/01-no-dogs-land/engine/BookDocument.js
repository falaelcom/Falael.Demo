"use strict";

include("StdAfx.js");

function BookDocument(resourceLoader, indexFile, isDebugMode)
{
	this.resourceLoader = resourceLoader;
	this.indexFile = indexFile;
	this.isDebugMode = isDebugMode;

	this.rooms = {};
	this.eventList = [];
	this.eventMap = {};
	this.mainRoomKey = null;
	this.restartRoomKey = null;

	this.stances = {};
	this.speedPointsToKmH = 0;
	this.defaultStanceKey = null;

	this.knowledgeTexts = {};
	this.skillTexts = {};
	this.inventoryTexts = {};
	this.stanceTexts = {};
	this.textDefs = {};
	this.mapData = {};
}

BookDocument.prototype.load = function (callback)
{
	var self = this;

	var context =
	{
		blend: [],
	};

	return this.loadIndexJsonFile(context, this.indexFile, function done()
	{
		if (!self.mainRoomKey)
		{
			return callback("Root JSON field mainRoomKey is required.");
		}
		if (!self.rooms[self.mainRoomKey])
		{
			return callback("A room with a key \"" + self.mainRoomKey + "\" (mainRoomKey) does not exist.");
		}
		if (!self.restartRoomKey)
		{
			self.restartRoomKey = self.mainRoomKey;
		}
		else if (!self.rooms[self.restartRoomKey])
		{
			return callback("A room with a key \"" + self.restartRoomKey + "\" (restartRoomKey) does not exist.");
		}

		self.applyBlend(context.blend);

		return callback();
	});
}

BookDocument.prototype.loadIndexJsonFile = function (context, relativePath, callback)
{
	var splitRoomDataContext =
	{
		autoGeneratedOnSlotPrefix: "__autoText__",
		autoGeneratedTestSlotPrefix: "__autoSwText__"
	};
	var loadRoomContext =
	{
		indexRootPath: Utility.IO.getDirectory(relativePath) + "/",
		autoGeneratedRoomKeyPostfix: "__autoFork__",
		splitRoomDataContext: splitRoomDataContext,
	};

	var self = this;
	var json = null;
	return async.waterfall(
	[
		function (next)
		{
			return self.resourceLoader.loadJsonFile(relativePath, next);
		},
		function (result, next)
		{
			json = result;

			self.mainRoomKey = self.mainRoomKey || json.mainRoomKey;
			self.restartRoomKey = self.restartRoomKey || json.restartRoomKey;
			if (json.stances)
			{
				for (var stanceKey in json.stances)
				{
					if (self.stances[stanceKey])
					{
						console.error("Duplicate stance key \"" + stanceKey + "\".");
						continue;
					}
					self.stances[stanceKey] = json.stances[stanceKey];
				}
			}
			self.defaultStanceKey = self.defaultStanceKey || json.defaultStanceKey;
			self.speedPointsToKmH = self.speedPointsToKmH || json.speedPointsToKmH;

			if (json.blend && json.blend.length)
			{
				context.blend = context.blend.concat(json.blend);
			}

			if (json.events && json.events.length)
			{
				throw new "Not implemented.";

				for(var length = json.events.length, i = 0; i < length; ++i)
				{
					var item = json.events[i];

					if (!item || !item.key)
					{
						return next("Invalid event definition " + JSON.stringify(item) + ".");
					}
					if (self.eventMap[item.key])
					{
						return next("Event definition with the same key already exists: " + JSON.stringify(item) + ", existing: " + JSON.stringify(self.eventMap[item.key]) + ".");
					}

					if (!item.trigger)
					{
						return next("The triger section is mandatory for events.");
					}
					if (!item.trigger.condition)
					{
						return next("The triger.condition section is mandatory for events.");
					}

					var event =
					{
						key: item.key,
						durationBefore: item.durationBefore ? GameTimeSpan.parse(item.durationBefore) : GameTimeSpan.zero,
						durationAfter: item.durationAfter ? GameTimeSpan.parse(item.durationAfter) : GameTimeSpan.zero,
						duration: item.duration ? GameTimeSpan.parse(item.duration) : GameTimeSpan.zero,
						trigger:
						{
							condition: item.trigger.condition,
						},
					};

					self.eventList.push(event);
					self.eventMap[event.key] = event;
				}
			}

			if (json.include && json.include.length)
			{
				return async.each(json.include, function readIndexJsonFile(item, each_next)
				{
					var localPath = item.replace(/^\/+|\/+$/g, "");
					var rootPath = Utility.IO.getDirectory(relativePath) + "/";
					return self.loadIndexJsonFile(context, rootPath + localPath, each_next);
				}, next);
			}
			else
			{
				return next();
			}
		},
		function (next)
		{
			return async.each(json.rooms, function(item, each_next)
			{
				return self.loadRoom(loadRoomContext, item.key, item, each_next);
			}, next);
		},
		function (next)
		{
			if (!json.mapData)
			{
				return next();
			}

			return async.forEachOf(json.mapData, function readMapData(value, key, each_next)
			{
				return async.waterfall(
				[
					function (waterfall_next)
					{
						if (self.mapData[key])
						{
							return waterfall_next("Duplicate map data reference key \"" + key + "\".");
						}
						if (!value)
						{
							return waterfall_next("Invalid map data reference \"" + key + "\": \"" + JSON.stringify(value) + "\".");
						}
						return self.resourceLoader.loadJsonFile(loadRoomContext.indexRootPath + value, waterfall_next);
					},
					function (mapData, waterfall_next)
					{
						self.mapData[key] = mapData;
						return waterfall_next();
					}
				], each_next);
			}, next);
		}
	], function done(err, result)
	{
		self.rebuildMapDataIndices();
		self.speedPointsToKmH = self.speedPointsToKmH || 1;

		if (err)
		{
			console.error(377002, err);
		}

		return callback(err);
	});
}

BookDocument.prototype.loadRoom = function (loadRoomContext, roomKey, item, next)
{
	var self = this;

	return async.waterfall(
	[
		function (waterfall_next)
		{
			if (!item)
			{
				return waterfall_next("Invalid room definition " + JSON.stringify(item) + ".");
			}
			if (roomKey && self.rooms[roomKey])
			{
				return waterfall_next("Room definition with the same key already exists: " + JSON.stringify(item) + ", existing: " + JSON.stringify(self.rooms[roomKey]) + ".");
			}
			if (!item.file)
			{
				return waterfall_next(null, null);
			}
			return self.resourceLoader.loadRoomFile(loadRoomContext.indexRootPath + item.file, function done(err, result)
			{
				if (err)
				{
					console.error("Cannot load room \"" + loadRoomContext.indexRootPath + item.file + "\".");
					return waterfall_next(true, null);
				}
				return waterfall_next(err, result);
			});
		},
		function (roomText, waterfall_next)
		{
			var roomData = null;
			if (roomText)
			{
				try
				{
					roomData = BookDocument.splitRoomData(loadRoomContext.splitRoomDataContext, item.file, roomText);
				}
				catch (ex)
				{
					return waterfall_next(ex);
				}
				for (var key in roomData.textDefs)
				{
					if (self.textDefs[key])
					{
						throw "Duplicate text def id: " + key;
					}
					self.textDefs[key] = roomData.textDefs[key];
				}
				if (roomData.json && roomData.json.knowledge)
				{
					for (var key in roomData.json.knowledge)
					{
						self.knowledgeTexts[key] = roomData.json.knowledge[key];
					}
				}
				if (roomData.json && roomData.json.skills)
				{
					for (var key in roomData.json.skills)
					{
						self.skillTexts[key] = roomData.json.skills[key];
					}
				}
				if (roomData.json && roomData.json.inventory)
				{
					for (var key in roomData.json.inventory)
					{
						self.inventoryTexts[key] = roomData.json.inventory[key];
					}
				}
				if (roomData.json && roomData.json.stances)
				{
					for (var key in roomData.json.stances)
					{
						self.stanceTexts[key] = roomData.json.stances[key];
					}
				}
			}

			var roomType = item.type;
			if (!roomType)
			{
				if (!roomKey)
				{
					roomType = "resource";
				}
				else if (item.paths)
				{
					roomType = "fork";
				}
				else if (item.target)
				{
					roomType = "redirect";
				}
				else if (roomText && roomData)
				{
					roomType = "text";
				}
				else
				{
					roomType = "hub";
				}
			}

			switch (roomType)
			{
				case "text":
					if (!roomData)
					{
						return waterfall_next("Invalid text room definition, room key: \"" + roomKey + "\".");
					}

					var room =
					{
						key: roomKey,
						type: roomType,
					};

					room.file = item.file;
					room.text = roomData.text;
					room.roomJson = roomData.json;
					room.exits = BookDocument.mergeExitData(item.exits, roomData.json ? roomData.json.exits : {}, self.textDefs);

					if (item.locationKey) room.locationKey = item.locationKey;
					if (item.duration) room.duration = item.duration;
					if (item.dateTime) room.dateTime = item.dateTime;

					if (item.onRoomEnter) room.onRoomEnter = self.translateStanceData(item.onRoomEnter);
					if (item.onRoomFinish) room.onRoomFinish = self.translateStanceData(item.onRoomFinish);
					if (item.onRoomExit) room.onRoomExit = self.translateStanceData(item.onRoomExit);

					room.onSlots = {};

					for (var key in item)
					{
						if (key.indexOf("on ") != 0)
						{
							continue;
						}
						var slotName = key.substr("on ".length);
						var slotActions = item[key];
						if (slotActions) room.onSlots[slotName] = self.translateStanceData(slotActions);
					}

					for (var length2 = roomData.autoOnSlots.length, i2 = 0; i2 < length2; ++i2)
					{
						var item2 = roomData.autoOnSlots[i2];
						var existingActions = room.onSlots[item2.name];
						if (!existingActions)
						{
							room.onSlots[item2.name] = item2.actions;
							continue;
						}
						for (var actionKey in item2.actions)
						{
							if (actionKey != "insertText")
							{
								throw "Invalid operation.";
							}
							if (!existingActions.insertText)
							{
								existingActions.insertText = item2.actions[actionKey];
								continue;
							}
							existingActions.insertText = existingActions.insertText.concat(item2.actions[actionKey]);
						}
					}

					if (item["combat1.0"])
					{
						room.combat1_0 = BookDocument.mergeCombat1_0Data(roomKey, item["combat1.0"], roomData.json ? roomData.json["combat1.0"] : {});
					}

					self.rooms[roomKey] = room;
					break;
				case "hub":
					var room =
					{
						key: roomKey,
						type: roomType,
						exits: item.exits,
					};
					if (item.onRoomEnter) room.onRoomEnter = self.translateStanceData(item.onRoomEnter);
					if (item.onRoomExit) room.onRoomExit = self.translateStanceData(item.onRoomExit);

					if (item.dateTime) room.dateTime = item.dateTime;

					self.rooms[roomKey] = room;
					break;
				case "redirect":
					var room =
					{
						key: roomKey,
						type: "hub",
						exits: [],
					};
					if (item.onRoomEnter) room.onRoomEnter = self.translateStanceData(item.onRoomEnter);
					if (item.onRoomExit) room.onRoomExit = self.translateStanceData(item.onRoomExit);
					if (item.dateTime) room.dateTime = item.dateTime;

					var exit =
					{
						target: item.target,
					};
					if (item.onExit) exit.onExit = item.onExit;
					if (item.onExitFinish) exit.onExitFinish = item.onExitFinish;
					if (item.duration) exit.duration = item.duration;
					if (item.route) exit.route = item.route;
					room.exits.push(exit);

					self.rooms[roomKey] = room;
					break;
				case "fork":
					var autoHubRoom =
					{
						key: roomKey,
						type: "hub",
						exits: [],
					};
					if (item.onRoomEnter) autoHubRoom.onRoomEnter = self.translateStanceData(item.onRoomEnter);
					if (item.onRoomExit) autoHubRoom.onRoomExit = self.translateStanceData(item.onRoomExit);

					if (item.dateTime) autoHubRoom.dateTime = item.dateTime;

					var autoGeneratedRoomKeyCounter = 0;
					self.rooms[roomKey] = autoHubRoom;
					return async.each(item.paths, function (item2, each_next)
					{
						var keyPostfix = null;
						if (item2.postfix)
						{
							keyPostfix = item2.postfix;
						}
						else
						{
							keyPostfix = autoGeneratedRoomKeyCounter;
							++autoGeneratedRoomKeyCounter;
						}
						var autoRoomKey = roomKey + " --> " + keyPostfix;
						return self.loadRoom(loadRoomContext, autoRoomKey, item2.room, function onRoomLoaded(err, result)
						{
							if (err)
							{
								return each_next(err);
							}
							var exit =
							{
								target: autoRoomKey,
							};
							if (item2.condition) exit.condition = item2.condition;
							if (item2.onExit) exit.onExit = item2.onExit;
							if (item2.onExitFinish) exit.onExitFinish = item2.onExitFinish;
							if (item2.duration) exit.duration = item2.duration;
							if (item2.route) exit.route = item2.route;
							autoHubRoom.exits.push(exit);
							return each_next();
						});
					}, waterfall_next);
				case "resource":
					break;
				default:
					return waterfall_next("Invalid room type \"" + item.type + "\", room key: \"" + roomKey + "\".");
			}

			if (room && item.bookmark)
			{
				var onRoomEnter = room.onRoomEnter;
				if (!onRoomEnter)
				{
					onRoomEnter = {};
					room.onRoomEnter = onRoomEnter;
				}
				onRoomEnter.addBookmark = item.bookmark;
			}

			return waterfall_next();
		}
	], function done(err, result)
	{
		if (err === true)
		{
			return next	(null, result);
		}
		if (err)
		{
			console.error("Cannot load room with key \"" + roomKey + "\".");
		}
		return next(err, result);
	});
}

BookDocument.prototype.applyBlend = function (blendArray)
{
	for (var length = blendArray.length, i = 0; i < length; ++i)
	{
		var blendItem = blendArray[i];
		if (!blendItem.targets || !blendItem.targets.length)
		{
			console.error("Blend requires targets.");
			continue;
		}
		for (var jlength = blendItem.targets.length, j = 0; j < jlength; ++j)
		{
			var target = blendItem.targets[j];
			this.applyBlendItemsForTarget(blendItem.items, target);
		}
	}
}

BookDocument.prototype.applyBlendItemsForTarget = function (targetedBlendItems, target)
{
	for (var length = targetedBlendItems.length, i = 0; i < length; ++i)
	{
		var item = targetedBlendItems[i];
		switch(item.how)
		{
			case "addSlotActions":
				this.applyBlendItem_addSlotActions(item, target);
				break;
			default:
				throw "Not implemented.";
		}
	}
}

BookDocument.prototype.applyBlendItem_addSlotActions = function (item, target)
{
	if (!item.where)
	{
		throw "Argument is null: item.where";
	}
	if (!item.what)
	{
		throw "Argument is null: item.what";
	}

	var filledInWhere = TemplateEngine.fillIn(item.where, { target: target } );
	var filledInWhat = this.translateStanceData(TemplateEngine.fillIn(item.what, { target: target }));

	var whereParts = filledInWhere.split('/');
	if (whereParts.length < 4)
	{
		throw "Blend: Invalid addSlotActions blend item \"where\" value: \"" + item.where + "\", \"" + filledInWhere + "\".";
	}
	
	var roomKey = whereParts[1];
	var room = this.getRoom(roomKey);
	
	if (!room)
	{
		throw "Blend: Room key not found: \"" + roomKey + "\".";
	}

	var roomElement = whereParts[2];

	switch(roomElement)
	{
		case "slots":
			var slotName = whereParts[3];
			var slot = room.onSlots[slotName];
			if (!slot)
			{
				slot = {};
				room.onSlots[slotName] = slot;
			}
			for (var key in filledInWhat)
			{
				var item2 = filledInWhat[key];
				var existingAction = slot[key];
				if (!existingAction)
				{
					slot[key] = item2;
					continue;
				}
				if (Object.isArray(existingAction))
				{
					if (!Object.isArray(item2))
					{
						console.error("Blend item must be an array", item2);
						continue;
					}
					slot[key] = existingAction.concat(item2);
					continue;
				}
				if (Object.isObject(existingAction))
				{
					if (!Object.isObject(item2))
					{
						console.error("Blend item must be an object", item2);
						continue;
					}
					if (this.isDebugMode)
					{
						console.warn("Blend will overwrite an existing action in slot (1) \"" + filledInWhere + "\"", item, existingAction);
					}
					Object.aggregate(existingAction, item2);
					continue;
				}
				if (this.isDebugMode)
				{
					console.warn("Blend will overwrite an existing action in slot (2) \"" + filledInWhere + "\"", item);
				}
				slot[key]= item2;
			}
			break;
		default:
			throw "Not implemented.";
	}
}

BookDocument.prototype.rebuildMapDataIndices = function ()
{
	for (var key in this.mapData)
	{
		var map = this.mapData[key];
		map.nodeIndex = {};
		for (var length = map.nodes.length, i = 0; i < length; ++i)
		{
			var item = map.nodes[i];
			if (item.name.indexOf('*') != -1)
			{
				throw "Invalid node name \"" + item.name + "\" in map \"" + key + "\". Unadmissible character '*'.";
			}
			if (map.nodeIndex[item.name])
			{
				throw "Duplicate node name \"" + item.name + "\" in map \"" + key + "\"";
			}
			map.nodeIndex[item.name] = item;
		}

		map.edgeIndex = {};
		var branchList = [];
		for (var length = map.edges.length, i = 0; i < length; ++i)
		{
			var item = map.edges[i];
			if (item.name == "_default")
			{
				throw "Invalid edge route name \"" + item.name + "\" in map \"" + key + "\". Name \"_default\" is reserved.";
			}

			var branch1Key = item.node1 + '*' + item.node2;
			var branch2Key = item.node2 + '*' + item.node1;

			var branch = map.edgeIndex[branch1Key];
			if (!branch)
			{
				branch =
				{
					routeList: [],
					routeMap:
					{
						_default: null,
					},
				};
				map.edgeIndex[branch1Key] = branch;
				map.edgeIndex[branch2Key] = branch;
				branchList.push(branch);
			}
			branch.routeList.push(item);
		}

		for (var length = branchList.length, i = 0; i < length; ++i)
		{
			var item = branchList[i];
			item.routeList.sort();
			for (var jlength = item.routeList.length, j = 0; j < jlength; ++j)
			{
				var jitem = item.routeList[j];
				if (item.routeMap[jitem.name])
				{
					throw "Duplicate edge route name \"" + jitem.name + "\" in edge \"" + JSON.stringify(jitem) + "\" in map \"" + key + "\".";
				}
				item.routeMap[jitem.name] = jitem;
			}
			item.routeMap._default = item.routeList[0];
			if (!item.routeMap._default)
			{
				throw "Invalid application state in map \"" + key + "\", route branch \"" + JSON.stringify(item) + "\".";
			}
		}
	}
}

BookDocument.prototype.getRoom = function (key)
{
	return this.rooms[key];
}

BookDocument.prototype.getDefaultRoom = function ()
{
	return this.rooms[this.mainRoomKey];
}

BookDocument.prototype.getRestartRoom = function ()
{
	return this.rooms[this.restartRoomKey];
}


BookDocument.prototype.getStances = function ()
{
	return this.stances;
}

BookDocument.prototype.getSpeedPointsToKmH = function ()
{
	return this.speedPointsToKmH;
}

BookDocument.prototype.getDefaultStanceKey = function ()
{
	return this.defaultStanceKey;
}

BookDocument.prototype.getStance = function (stanceKey)
{
	return this.stances[stanceKey];
}

BookDocument.prototype.getStanceTextItems = function (stanceKey)
{
	return this.stanceTexts[stanceKey];
}

BookDocument.prototype.getDefaultStance = function ()
{
	return this.stances[this.defaultStanceKey];
}

BookDocument.prototype.translateStanceData = function (actions)
{
	var result = {};
	for (var key in actions)
	{
		var item = actions[key];
		if (key != "changeStance")
		{
			result[key] = item;
			continue;
		}
		var stanceKey = item;
		var stance = this.getStance(stanceKey);
		if (!stance)
		{
			console.error("Invalid argument value for stance: " + stanceKey);
			stance = bookDocument.getDefaultStance();
		}
		result[key] =
        {
		    key: stanceKey,
	        properties: stance.properties,
        };
	}
	return result;
}

BookDocument.prototype.getKnowledgeText = function (key)
{
	return this.knowledgeTexts[key];
}

BookDocument.prototype.getSkillText = function (key)
{
	return this.skillTexts[key];
}

BookDocument.prototype.getInventoryText = function (key)
{
	return this.inventoryTexts[key];
}

BookDocument.prototype.getTextDef = function (key)
{
	return this.textDefs[key];
}

BookDocument.prototype.getLocationData = function (locationKeyReference)
{
	var locationKey = BookDocument.parseLocationKey(locationKeyReference);
	var map = this.mapData[locationKey.map];
	if (!map)
	{
		throw "Invalid map key in location key reference \"" + locationKeyReference + "\"";
	}
	var result = map.nodeIndex[locationKey.location];
	if (!result)
	{
		throw "Invalid location key in location key reference \"" + locationKeyReference + "\"";
	}
	return result;
}

BookDocument.prototype.getRouteData = function (locationKeyReference1, locationKeyReference2)
{
	var locationKey1 = BookDocument.parseLocationKey(locationKeyReference1);
	var locationKey2 = BookDocument.parseLocationKey(locationKeyReference2);

	if (locationKey1.map != locationKey2.map)
	{
		return null;
	}

	var map = this.mapData[locationKey1.map];
	if (!map)
	{
		throw "Invalid map key in location key reference \"" + locationKeyReference1 + "\"";
	}
	var branchKey = locationKey1.location + '*' + locationKey2.location;
	return map.edgeIndex[branchKey];
}

BookDocument.prototype.getDistanceBetweenRooms = function (room1, room2, route)
{
	if (!room1.locationKey)
	{
		return -1;
	}
	if (!room2.locationKey)
	{
		return -1;
	}

	var room1LocationData = this.getLocationData(room1.locationKey);
	var room2LocationData = this.getLocationData(room2.locationKey);

	if (route == "air")
	{
		var a = Math.abs(room1LocationData.xM - room2LocationData.xM);
		var b = Math.abs(room1LocationData.yM - room2LocationData.yM);
		return Math.round(Math.sqrt(a * a + b * b) * 100) / 100;
	}

	var routeData = this.getRouteData(room1.locationKey, room2.locationKey);
	if (!routeData)
	{
		return -1;
	}

	if (!route)
	{
		return routeData.routeMap._default.distanceM;
	}

	var edge = routeData.routeMap[route];
	if (!edge)
	{
		throw "Route name \"" + route + "\" between nodes \"" + room1.locationKey + "\" and \"" + room2.locationKey + "\" not found.";
	}
	return edge.distanceM;
}


BookDocument.prototype.buildImagePath = function (localImagePath)
{
	var localPath = localImagePath.replace(/^\/+|\/+$/g, "");
	return this.resourceLoader.ioBasePath + this.resourceLoader.resourcesRoot + localPath;
}


BookDocument.splitRoomData = function (splitRoomDataContext, fileName, roomData)
{
	var result =
	{
		text: null,
		json: null,
		textDefs: {},
		autoOnSlots: [],
	};

	var textSb = [];
	var jsonSb = [];
	var instructionNameSb = [];
	var instructionArgSb = [];
	var textDefSb = [];
	var tempSb = null;
	
	var STATE_TEXT = 1;
	var STATE_JSON = 2;
	var STATE_INSTRUCTION_CANDIDATE = 3;
	var STATE_INSTRUCTION = 4;
	var STATE_INSTRUCTION_ARGS = 5;
	var STATE_TEXTDEF = 6;
	var STATE_TEST = 7;

	var state = STATE_TEXT;
	var instructionBackState = STATE_TEXT;  //  abomination; split the current automation on text parser and instruction processor to resolve

	var curlyBracketCount = 0;
	var instructionName = null;
	var instructionArgs = [];

	var textDefTextId = null;

	var onSlotId = null;
	var autoGeneratedOnSlotCounter = 0;
	var onInstructionArgs = null;

	var testSlotId = null;
	var autoGeneratedTestSlotCounter = 0;
	var testInstructionArgs = null;
	var testSelectInsertTextItems = [];
	var ifTextId = null;

	for (var length = roomData.length, i = 0; i < length; ++i)
	{
		var c = roomData[i];
		switch (state)
		{
			case STATE_TEXT:
				switch (c)
				{
					case '{':
						if (jsonSb.length)
						{
							throw "Invalid room data, multiple JSON blocks are not allowed.";
						}
						++curlyBracketCount;
						jsonSb.push(c);
						state = STATE_JSON;
						break;
					case '}':
						throw "Invalid room data, too many closing curly brackets.";
					case '@':
						state = STATE_INSTRUCTION_CANDIDATE;
						tempSb = textSb;
						break;
					default:
						textSb.push(c);
						break;
				}
				break;
			case STATE_JSON:
				switch (c)
				{
					case '{':
						++curlyBracketCount;
						jsonSb.push(c);
						break;
					case '}':
						jsonSb.push(c);
						--curlyBracketCount;
						if (curlyBracketCount == 0)
						{
							state = STATE_TEXT;
						}
						break;
					default:
						jsonSb.push(c);
						break;
				}
				break;
			case STATE_INSTRUCTION_CANDIDATE:
				switch (c)
				{
					case '@':
						instructionName = null;
						instructionArgs = [];
						instructionNameSb = [];
						instructionArgSb = [];
						state = STATE_INSTRUCTION;
						break;
					default:
						tempSb.push("@");
						tempSb.push(c);
						state = instructionBackState;   //  STATE_TEXT or STATE_TEXTDEF
						break;
				}
				break;
			case STATE_INSTRUCTION:
				switch (c)
				{
					case '@':
						instructionName = instructionNameSb.join("");
						switch (instructionName)
						{
							case "DEF":
								throw "The DEF instruction has one required parameter.";
							case "ENDDEF":
								result.textDefs[textDefTextId] = textDefSb.join("");
								textDefTextId = null;
								instructionBackState = STATE_TEXT;
								state = STATE_TEXT;
								break;
							case "ENDON":
								textSb.push('@' + onSlotId + '@');
								var textDefText = textDefSb.join("");
								if (textDefText.length)
								{
									result.textDefs[onSlotId] = textDefText;
									result.autoOnSlots.push(
									{
										name: onSlotId,
										actions:
										{
											insertText:
											[{
												textId: onSlotId,
												condition: { test: onInstructionArgs[0] },
												onlyOnce: BookDocument.parseOnInstructionOptions(onInstructionArgs[1]),
											}]
										}
									});
								}
								onSlotId = null;
								instructionBackState = STATE_TEXT;
								state = STATE_TEXT;
								break;
							case "ENDTEST":
								if (ifTextId)
								{
									result.textDefs[ifTextId] = textDefSb.join("");
								}
								textDefSb = [];
								textSb.push('@' + testSlotId + '@');
								result.autoOnSlots.push(
								{
									name: testSlotId,
									actions:
									{
										selectInsertText: testSelectInsertTextItems,
									}
								});
								testSlotId = null;
								instructionBackState = STATE_TEXT;
								state = STATE_TEXT;
								break;
							case "TEST":
								throw "The TEST instruction must have one parameter.";
							case "IF":
								throw "The IF instruction must have at least one parameter.";
							case "ELSE":
								if (ifTextId)
								{
									result.textDefs[ifTextId] = textDefSb.join("");
								}
								textDefSb = [];
								ifTextId = "[" + fileName + "]." + splitRoomDataContext.autoGeneratedTestSlotPrefix + autoGeneratedTestSlotCounter;
								++autoGeneratedTestSlotCounter;
								testSelectInsertTextItems.push(
								{
									textId: ifTextId,
								});
								state = STATE_TEXTDEF;
								break;
							case "ON":
								throw "The ON instruction must have at least one parameter.";
							case "INSERT":
								throw "The INSERT instruction has one required parameter.";
							default:
								throw "Unknown instruction " + instructionName + ".";
						}
						break;
					case ' ':
						instructionName = instructionNameSb.join("");
						state = STATE_INSTRUCTION_ARGS;
						break;
					default:
						instructionNameSb.push(c);
						break;
				}
				break;
			case STATE_INSTRUCTION_ARGS:
				switch (c)
				{
					case '@':
						if (instructionArgSb.length)
						{
							instructionArgs.push(instructionArgSb.join(""));
						}
						switch (instructionName)
						{
							case "DEF":
								textDefSb = [];
								textDefTextId = instructionArgs[0];
								state = STATE_TEXTDEF;
								break;
							case "ON":
								if (onSlotId)
								{
									textSb.push('@' + onSlotId + '@');
									var textDefText = textDefSb.join("");
									if (textDefText.length)
									{
										result.textDefs[onSlotId] = textDefText;
										result.autoOnSlots.push(
										{
											name: onSlotId,
											actions:
											{
												insertText:
												[{
													textId: onSlotId,
													condition: { test: onInstructionArgs[0] },
													onlyOnce: BookDocument.parseOnInstructionOptions(onInstructionArgs[1]),
												}]
											}
										});
									}
								}

								textDefSb = [];
								onInstructionArgs = instructionArgs;
								onSlotId = "[" + fileName + "]." + splitRoomDataContext.autoGeneratedOnSlotPrefix + autoGeneratedOnSlotCounter;
								++autoGeneratedOnSlotCounter;
								state = STATE_TEXTDEF;
								break;
							case "TEST":
								ifTextId = null;
								testSelectInsertTextItems = [];
								testInstructionArgs = instructionArgs;
								testSlotId = "[" + fileName + "]." + splitRoomDataContext.autoGeneratedTestSlotPrefix + autoGeneratedTestSlotCounter;
								++autoGeneratedTestSlotCounter;
								state = STATE_TEXTDEF;
								break;
							case "IF":
								if (ifTextId)
								{
									result.textDefs[ifTextId] = textDefSb.join("");
								}
								textDefSb = [];
								ifTextId = "[" + fileName + "]." + splitRoomDataContext.autoGeneratedTestSlotPrefix + autoGeneratedTestSlotCounter;
								++autoGeneratedTestSlotCounter;
								switch (instructionArgs[0])
								{
									case "true":
										testSelectInsertTextItems.push(
										{
											textId: ifTextId,
											condition: { test: testInstructionArgs[0] },
											onlyOnce: BookDocument.parseOnInstructionOptions(instructionArgs[1]),
										});
										break;
									case "false":
										testSelectInsertTextItems.push(
										{
											textId: ifTextId,
											condition: { not: { test: testInstructionArgs[0] } },
											onlyOnce: BookDocument.parseOnInstructionOptions(instructionArgs[1]),
										});
										break;
									default:
										throw "Not implemented.";
								}
								state = STATE_TEXTDEF;
								break;
							case "ELSE":
								if (ifTextId)
								{
									result.textDefs[ifTextId] = textDefSb.join("");
								}
								textDefSb = [];
								ifTextId = "[" + fileName + "]." + splitRoomDataContext.autoGeneratedTestSlotPrefix + autoGeneratedTestSlotCounter;
								++autoGeneratedTestSlotCounter;
								testSelectInsertTextItems.push(
								{
									textId: ifTextId,
									onlyOnce: BookDocument.parseOnInstructionOptions(instructionArgs[0]),
								});
								state = STATE_TEXTDEF;
								break;
							case "ENDDEF":
								throw "The ENDDEF instruction has no parameters.";
							case "ENDON":
								throw "The ENDON instruction has no parameters.";
							case "ENDTEST":
								throw "The ENDTEST instruction has no parameters.";
							case "INSERT":
								if (!onSlotId)
								{
									var slotId = "[" + fileName + "]." + splitRoomDataContext.autoGeneratedOnSlotPrefix + autoGeneratedOnSlotCounter;
									++autoGeneratedOnSlotCounter;
									textSb.push('@' + slotId + '@');
									result.autoOnSlots.push(
									{
										name: slotId,
										actions:
										{
											insertText: [{ textId: instructionArgs[0] }]
										}
									});
									state = STATE_TEXT;
								}
								else
								{
									result.autoOnSlots.push(
									{
										name: onSlotId,
										actions:
										{
											insertText:
											[{
												textId: instructionArgs[0],
												condition: { test: onInstructionArgs[0] },
												onlyOnce: BookDocument.parseOnInstructionOptions(onInstructionArgs[1]),
											}]
										}
									});
									state = STATE_TEXTDEF;
								}
								break;
							default:
								throw "Unknown instruction " + instructionName + ".";
						}
						break;
					case ' ':
					case '\t':
						break;
					case ',':
						instructionArgs.push(instructionArgSb.join(""));
						instructionArgSb = [];
						break;
					default:
						instructionArgSb.push(c);
						break;
				}
				break;
			case STATE_TEXTDEF:
				switch (c)
				{
					case '{':
						throw "Cannot nest JSON in text defs (1) (@@DEF, @@ON, @@TEST) - check for closing @@ENDDEF, @@ENDON, @@ENDTEST instructions.";
					case '}':
						throw "Cannot nest JSON in text defs (2) (@@DEF, @@ON, @@TEST) - check for closing @@ENDDEF, @@ENDON, @@ENDTEST instructions.";
					case '@':
						instructionBackState = STATE_TEXTDEF;
						state = STATE_INSTRUCTION_CANDIDATE;
						tempSb = textDefSb;
						break;
					default:
						textDefSb.push(c);
						break;
				}
				break;
			default:
				throw "Invalid state.";
		}
	}

	result.text = textSb.join("");
	var jsonText = jsonSb.join("");
	if (jsonText != "")
	{
		try
		{
			result.json = JSON.parse(jsonText);
		}
		catch (ex)
		{
			throw "Bad JSON in room: " + fileName + ": " + jsonText + ". " + ex.toString();
		}
	}

	if (curlyBracketCount > 0)
	{
		throw "Invalid room data, not enough closing curly brackets.";
	}
	return result;
}

BookDocument.parseOnInstructionOptions = function (text)
{
	//	TODO: better implementation to support multilple options
	if (!text)
	{
		return null;
	}
	if (text.indexOf("onlyOnce(") != 0)
	{
		throw "Invalid @@ON instruction options in second argument (1).";
	}
	if (text.indexOf(")") != text.length - 1)
	{
		throw "Invalid @@ON instruction options in second argument (2).";
	}
	return text.substr("onlyOnce(".length, text.length - "onlyOnce(".length - 1).trim();
}

BookDocument.mergeExitData = function (exitArray, textDefinitions, globalTextDefinitions)
{
	if (!exitArray || !exitArray.length)
	{
		return [];
	}
	var result = [];
	for (var length = exitArray.length, i = 0; i < length; ++i)
	{
		var item = exitArray[i];
		var resultItem =
		{
			text: null,
			target: item.target,
			systemTarget: item.systemTarget,
		};

		if (item.text)
		{
			resultItem.text = textDefinitions[item.text] || "(text id \"" + item.text + "\" not found)";
		}
		else if (item.textId)
		{
			resultItem.textId = item.textId;
		}
		else
		{
			resultItem.text = "(no text id specified)";
		}

		if (item.condition)
		{
			resultItem.condition = item.condition;
		}
		if (item.onExit)
		{
			resultItem.onExit = item.onExit;
		}
		if (item.onExitFinish)
		{
			resultItem.onExitFinish = item.onExitFinish;
		}
		if (item.ignoreActions)
		{
			resultItem.ignoreActions = item.ignoreActions;
		}
		if (item.duration)
		{
			resultItem.duration = item.duration;
		}
		if (item.route)
		{
			resultItem.route = item.route;
		}
		result.push(resultItem);
	}
	return result;
}

BookDocument.mergeCombat1_0Data = function (roomKey, combatData, resourceDef)
{
	if (!combatData)
	{
		return null;
	}
	var result =
	{
		name: resourceDef ? resourceDef.name : "(combat1.0 resources for room \"" + roomKey + "\" not found)",
		image: resourceDef ? resourceDef.image : null,
		hp: combatData.hp,
		might: combatData.might,
		advantage: combatData.advantage,
		playerVictoryTextId: combatData.playerVictoryTextId,
		playerDefeatTextId: combatData.playerDefeatTextId,
	};

	return result;
}

BookDocument.parseLocationKey = function (locationKey)
{
	var parts = locationKey.split(':');
	if (parts.length != 2)
	{
		throw "Invalid location key reference format in location key \"" + locationKey + "\"";
	}
	return {
		map: parts[0],
		location: parts[1],
	};
}
